@using System.Threading
@using Microsoft.JSInterop
@using Soenneker.Blazor.MediaQuery.Abstract
@using Soenneker.Extensions.String
@using Soenneker.Extensions.ValueTask
@using Soenneker.Extensions.CancellationTokens

@inherits Soenneker.Quark.Components.Cancellable.CancellableComponent
@implements IMediaQuery
@inject IMediaQueryInterop MediaQueryInterop

<div id="@_elementId" >
    @if (_matches)
    {
        @ChildContent
    }
</div>

@code {

    [EditorRequired]
    [Parameter]
    public string Query { get; set; } = null!;

    [Parameter]
    public RenderFragment ChildContent { get; set; } = null!;

    private bool _matches;
    private bool _previousMatches;

    private DotNetObjectReference<MediaQuery>? _objRef;

    private readonly string _elementId;

    public MediaQuery()
    {
        _elementId = '_' + Guid.NewGuid().ToString();
    }

    protected override async Task OnInitializedAsync()
    {
        Query.ThrowIfNullOrWhiteSpace();

        await MediaQueryInterop.Initialize(CancellationToken);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objRef = DotNetObjectReference.Create(this);

            await MediaQueryInterop.Create(_objRef, _elementId, Query, CancellationToken);
            await MediaQueryInterop.CreateObserver(_elementId, CancellationToken);
        }
    }

    protected override bool ShouldRender()
    {
        return _matches != _previousMatches;
    }

    public async ValueTask<bool> IsMediaQueryMatched(string query, CancellationToken cancellationToken = default)
    {
        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
        {
            return await MediaQueryInterop.IsMediaQueryMatched(query, linked);
        }
    }

    [JSInvokable]
    public void UpdateMatches(bool match)
    {
        if (_matches == match)
            return;

        _previousMatches = _matches;
        _matches = match;
        StateHasChanged();
    }

    public override async ValueTask DisposeAsync()
    {
        await base.DisposeAsync();

        _objRef?.Dispose();
    }

}
