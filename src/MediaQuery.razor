@using System.Threading
@using Microsoft.JSInterop
@using Soenneker.Blazor.MediaQuery.Abstract
@using Soenneker.Extensions.String
@using Soenneker.Extensions.CancellationTokens
@using Soenneker.Extensions.ValueTask

@inherits Soenneker.Quark.CoreCancellableElement
@implements IMediaQuery
@inject IMediaQueryInterop MediaQueryInterop

<div id="@Id" >
    @if (_matches)
    {
        @ChildContent
    }
</div>

@code {

    [EditorRequired, Parameter]
    public string Query { get; set; } = null!;

    private bool _matches;
    private bool _previousMatches;
    private bool _initializedInJs;
    private bool _hasRendered;

    private DotNetObjectReference<MediaQuery>? _objRef;

    public MediaQuery()
    {
        Id = '_' + Guid.NewGuid().ToString("N");
    }

    protected override Task OnInitializedAsync()
    {
        Query.ThrowIfNullOrWhiteSpace();
        return Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _hasRendered = true;

        if (firstRender && !_initializedInJs)
        {
            try
            {
                _objRef = DotNetObjectReference.Create(this);

                await MediaQueryInterop.Create(_objRef, Id!, Query, CancellationToken);
                await MediaQueryInterop.CreateObserver(Id!, CancellationToken);

                _initializedInJs = true;
            }
            catch (InvalidOperationException)
            {
                // Happens during prerender; when the circuit becomes interactive,
                // we’ll get another render and try again.
                _initializedInJs = false;
                StateHasChanged();
            }
        }
    }

    protected override bool ShouldRender()
    {
        // Always allow the very first render; afterward only when match state changes.
        if (!_hasRendered)
            return true;
        return _matches != _previousMatches;
    }

    [JSInvokable]
    public void UpdateMatches(bool match)
    {
        if (_matches == match)
            return;

        _previousMatches = _matches;
        _matches = match;
        StateHasChanged();
    }

    public async ValueTask<bool> IsMediaQueryMatched(string query, CancellationToken cancellationToken = default)
    {
        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
        {
            return await MediaQueryInterop.IsMediaQueryMatched(query, linked);
        }
    }

    public override async ValueTask DisposeAsync()
    {
        _objRef?.Dispose();
        await base.DisposeAsync().NoSync();
    }

}